Given a linked list, 
swap every two adjacent nodes and return its head. 
You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)

Example 1:
Input: head = [1,2,3,4]
Output: [2,1,4,3]

Example 2:
Input: head = []
Output: []

Example 3:
Input: head = [1]
Output: [1]
 
Constraints:
The number of nodes in the list is in the range [0, 100].
0 <= Node.val <= 100


// My First solution
class Solution:
    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:
        def swap(prev, curr, nxt):
            if curr and nxt:
                prev.next = nxt
                curr.next = nxt.next
                nxt.next = curr
                if curr.next:
                    return swap(curr, curr.next, curr.next.next)
        if not head: return head
        elif not head.next: return head
        else:
            start = ListNode(0, head)
            swap(start, head, head.next)
        return start.next

result ->

55 / 55 test cases passed.
Status: Accepted
Runtime: 36 ms (73%)
Memory Usage: 13.8 MB (64%)