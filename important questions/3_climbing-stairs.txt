70. Climbing Stairs
Easy

You are climbing a staircase. It takes n steps to reach the top.
Each time you can either climb 1 or 2 steps. I
n how many distinct ways can you climb to the top?


Example 1:
Input: n = 2
Output: 2
Explanation: There are two ways to climb to the top.
1. 1 step + 1 step
2. 2 steps

Example 2:
Input: n = 3
Output: 3
Explanation: There are three ways to climb to the top.
1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step
 
Constraints:
1 <= n <= 45


// My first solution, 
class Solution:
    def climbStairs(self, n: int) -> int:
        ways = [1,2]
        count = 0
        index = 0
        while index < len(ways):
            curr = ways[index]
            if curr == n: count += 1
            elif curr < n:
                ways.append(curr+1)
                ways.append(curr+2)
            index += 1
        return count

// Gives TLE


// My second solution
// notice the pattern
// 1 - 1
// 2 - 2
// 3 - 3
// 4 - 5
// 5 - 8
// 6 - 13
// 7 - 21

// positions at a current step is always the sum of positions at the previous two steps

// so solution becomes
class Solution:
    def climbStairs(self, n: int) -> int:
        if n < 2: return n
        
        ways = [0]*n
        ways[0] = 1; ways[1] = 2
        
        for i in range(2, n):
            ways[i] = ways[i-1] + ways[i-2]
        return ways[-1]

Runtime: 49 ms, faster than 29.57% of Python3 online submissions for Climbing Stairs.
Memory Usage: 13.8 MB, less than 56.24% of Python3 online submissions for Climbing Stairs.
 

// for a better space solution
class Solution:
    def climbStairs(self, n: int) -> int:
        if n <= 2: return n
        
        ans = 0
        first = 1
        second = 2
        
        for i in range(2, n):
            ans = first + second
            first = second
            second = ans
        return ans
            
Runtime: 42 ms, faster than 48.39% of Python3 online submissions for Climbing Stairs.
Memory Usage: 13.8 MB, less than 96.33% of Python3 online submissions for Climbing Stairs.


// for the math nerds
nth term of a fibo sequence can be directly found o(1) with the formula
nth term = (psi**(n+1)) / root(5)
where psi = (1 + root(5)) / 2

so code becomes
import math 
class Solution:
    def climbStairs(self, n: int) -> int:
        root5 = math.sqrt(5)
        psi = (1 + root5)/2
        return round((1/root5) * (psi**(n+1)))