1166. Design File System
Medium

306

26

Add to List

Share
You are asked to design a file system that allows you to create new paths and associate them with different values.

The format of a path is one or more concatenated strings of the form: / followed by one or more lowercase English letters. 
For example, "/leetcode" and "/leetcode/problems" are valid paths while an empty string "" and "/" are not.

Implement the FileSystem class:
bool createPath(string path, int value) Creates a new path and associates a value to it if possible and returns true. 
Returns false if the path already exists or its parent path doesn't exist.
int get(string path) Returns the value associated with path or returns -1 if the path doesn't exist.
 
Example 1:
Input: 
["FileSystem","createPath","get"]
[[],["/a",1],["/a"]]
Output: 
[null,true,1]
Explanation: 
FileSystem fileSystem = new FileSystem();

fileSystem.createPath("/a", 1); // return true
fileSystem.get("/a"); // return 1

Example 2:
Input: 
["FileSystem","createPath","createPath","get","createPath","get"]
[[],["/leet",1],["/leet/code",2],["/leet/code"],["/c/d",1],["/c"]]
Output: 
[null,true,true,2,false,-1]
Explanation: 
FileSystem fileSystem = new FileSystem();
fileSystem.createPath("/leet", 1); // return true
fileSystem.createPath("/leet/code", 2); // return true
fileSystem.get("/leet/code"); // return 2
fileSystem.createPath("/c/d", 1); // return false because the parent path "/c" doesn't exist.
fileSystem.get("/c"); // return -1 because this path doesn't exist.

Constraints:
The number of calls to the two functions is less than or equal to 104 in total.
2 <= path.length <= 100
1 <= value <= 109


// My solution
class FileSystem:

    def __init__(self):
        self.fs = {}
        
        
    def createPath(self, path: str, value: int) -> bool:
        # If file system is empty, we have to create a path
        if not self.fs: 
            curr_path = path.split("/")[1:]
            # if current path has a parent and child path, return False
            # else add it to files system, and return True
            if len(curr_path) == 1:
                self.fs[path] = value
                return True
            else: 
                return False
            
        # If file system already has paths
        else:
            curr_path = path.split("/")[1:]
            # Add file if the path is a unique parent path
            if len(curr_path) == 1 and path not in self.fs: 
                self.fs[path] = value
                return True
            # if path is already present, return False
            if path in self.fs: 
                return False
            
            # This point means, the path is a nested path with parent + child(ren)
            i = 0
            keys = list(self.fs.keys())
            while i < len(self.fs):
                # go through all paths in file system
                # if current path to be added matches a path in file system (upto the len of path in system), we have a match
                loc = keys[i].split("/")[1:]
                if curr_path[:len(loc)] == loc:
                    # now if path to be added has just one more sub-path, it is valid, and add it into system
                    if len(curr_path) - len(loc) == 1:
                        self.fs[path] = value
                        return True
                    else:
                        i += 1
                        continue
                i += 1
                
            # if the path has not been added yet, it is an illegal path, so return False
            return False

    def get(self, path: str) -> int:
        if path in self.fs: return self.fs[path]
        else: return -1


# Your FileSystem object will be instantiated and called as such:
# obj = FileSystem()
# param_1 = obj.createPath(path,value)
# param_2 = obj.get(path)



// brilliant, inspired solution
class FileSystem:

    def __init__(self):
        self.paths = defaultdict()

    def createPath(self, path: str, value: int) -> bool:
        
        # Step-1: basic path validations
        if path == "/" or len(path) == 0 or path in self.paths:
            return False
        
        # Step-2: if the parent doesn't exist. Note that "/" is a valid parent.
        parent = path[:path.rfind('/')]
        if len(parent) > 1 and parent not in self.paths:
            return False
        
        # Step-3: add this new path and return true.
        self.paths[path] = value
        return True

    def get(self, path: str) -> int:
        return self.paths.get(path, -1)