Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), 
ans[i] is the number of 1's in the binary representation of i.


Example 1:
Input: n = 2
Output: [0,1,1]
Explanation:
0 --> 0
1 --> 1
2 --> 10

Example 2:
Input: n = 5
Output: [0,1,1,2,1,2]
Explanation:
0 --> 0
1 --> 1
2 --> 10
3 --> 11
4 --> 100
5 --> 101 

Constraints:
0 <= n <= 105
 

Follow up:
It is very easy to come up with a solution with a runtime of O(n log n). Can you do it in linear time O(n) and possibly in a single pass?
Can you do it without using any built-in function (i.e., like __builtin_popcount in C++)?


// My first solution
class Solution:
    def countBits(self, n: int) -> List[int]:
        if n == 0: return [0]
        elif n == 1: return [0, 1]
        out = [0, 1]
        for i in range(2, n+1):
            divisor, divident, remainder = 2, i, 0
            while divident > 1:
                remainder += divident % divisor
                divident = divident // 2
            out.append(remainder+1)
        return out

result ->
Submission Detail
15 / 15 test cases passed.
Status: Accepted
Runtime: 188 ms (25%)
Memory Usage: 20.7 MB (82%)


Approach 3: DP + Least Significant Bit
Intuition

We can have different transition functions, as long as x'x is smaller than xx and their pop counts have a function.

Algorithm
Following the same principle of the previous approach, we can also have a transition function by playing with the least significant bit.
Let look at the relation between xx and x' = x / 2x 
Thus, we have the following transition function of pop count P(x)P(x):

P(x) = P(x / 2) + (x mod 2)
P(x) = P(x/2)+(xmod2)

// second solution, inspired 
ans = [0] * (n + 1)
for x in range(1, n+1):
	ans[x] = ans[x>>1]+(x%2)
	# or ans[x] = ans[x>>1]+(x & 1) as (x & 1) equals x % 2
return ans


// third solution, inspired 
P(x)=P(x&(xâˆ’1))+1
ans = [0] * (n + 1)
for x in range(1, n+1):
	ans[x] = ans[x & (x-1)]+1
return ans
