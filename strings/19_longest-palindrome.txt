Given a string s, return the longest palindromic substring in s.

Example 1:
Input: s = "babad"
Output: "bab"
Explanation: "aba" is also a valid answer.

Example 2:
Input: s = "cbbd"
Output: "bb"
 
Constraints:
1 <= s.length <= 1000
s consist of only digits and English letters.

Amazon, Microsoft, Google, Adobe, Apple, Oracle, Facebook, Bloomberg, Goldman Sachs, Yahoo, tiktok, Visa, Uber, Walmart, Global Tech, ByteDance, PayTM.

// My solution
class Solution:
    def longestPalindrome(self, s: str) -> str:
        # best way to check for a palindrome is to start from the middle index
        # and make way towards the left and right edge of string
        
        def check_palindrome(s, left, right):
            while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1; right += 1
            # when while loop stops, both left and right are +-1 away from true indexes, so return indices excluding extremes
            return s[left+1:right] 
        
        longest = ''
        for i in range(len(s)):
            palindrome = check_palindrome(s, left=i, right=i)    # middle index for checking odd palindromes
            if len(longest) < len(palindrome): longest = palindrome
            palindrome = check_palindrome(s, left=i, right=i+1)  # two indexes for checking even palindromes
            if len(longest) < len(palindrome): longest = palindrome
        return longest

result -> 
Runtime: 840 ms, faster than 87.48% of Python3 online submissions for Longest Palindromic Substring.
Memory Usage: 13.9 MB, less than 91.60% of Python3 online submissions for Longest Palindromic Substring.