You are given the head of a linked list, and an integer k.
Return the head of the linked list after swapping the values of the kth node from the beginning and the kth node from the end (the list is 1-indexed).

Difficulty -> Medium

Example 1:
Input: head = [1,2,3,4,5], k = 2
Output: [1,4,3,2,5]

Example 2:
Input: head = [7,9,6,6,7,8,3,0,9,5], k = 5
Output: [7,9,6,6,8,7,3,0,9,5]
 
Constraints:
The number of nodes in the list is n.
1 <= k <= n <= 105
0 <= Node.val <= 100


// My first solution
class Solution:
    def get_count(self, head):
        p, count = head, 0
        while p:
            count += 1
            p = p.next
        return count
        
    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:

        count = self.get_count(head)
        if count == 1: return head

        front, rear, index = k, count-k, 0
        p1 = p2 = head
        while index < max(front, rear):
            index += 1
            if index < front: p1 = p1.next
            if index <= rear: p2 = p2.next
        p1.val, p2.val = p2.val, p1.val
        return head

result ->
Submission Detail
132 / 132 test cases passed.
Status: Accepted
Runtime: 1172 ms (75%)
Memory Usage: 48.3 MB (85%)


// single pass
// use end node technique to get kth node from end of linked list in one pass
class Solution:
        
    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        length, end = 0, None
        p1 = p2 = curr = head
        while curr:
            length += 1
            if end: end = end.next
            if length == k:
                first = curr
                end = head
            curr = curr.next
        first.val, end.val = end.val, first.val
        return head