iven the head of a singly linked list, 
group all the nodes with odd indices together followed by the nodes with even indices, 
and return the reordered list.

The first node is considered odd, and the second node is even, and so on.
Note that the relative order inside both the even and odd groups should remain as it was in the input.

Follow up: You must solve the problem in O(1) extra space complexity and O(n) time complexity. 

Example 1:
Input: head = [1,2,3,4,5]
Output: [1,3,5,2,4]

Example 2:
Input: head = [2,1,3,5,6,4,7]
Output: [2,3,6,7,1,5,4]
 
Constraints:
n == number of nodes in the linked list
0 <= n <= 104
-106 <= Node.val <= 106


// My first solution
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def oddEvenList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        # handle corner cases
        if head == None or head.next == None: return head
        
        # Use two pointers, odd and even
        # In each iteration, link next odd element to current odd element (1->3)
        # and next even element to current even element (2->4)
        # this creates two links, one of odd nodes and one of even nodes
        # after traversing the entire linked list,
        # connect last node of odd links with first node of even links
        odd, even = head, head.next
        temp = even # hold the start of even nodes
        while odd.next and even.next:
            odd.next = even.next
            odd = odd.next
            even.next = odd.next
            even = even.next
        odd.next = temp # connect the two links
        return head

result -> Submission Detail
70 / 70 test cases passed.
Status: Accepted
Runtime: 44 ms (90%)
Memory Usage: 16.6 MB (65%)