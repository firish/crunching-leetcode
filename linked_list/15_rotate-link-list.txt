Given the head of a linked list, rotate the list to the right by k places.

Example 1:
Input: head = [1,2,3,4,5], k = 2
Output: [4,5,1,2,3]

Example 2:
Input: head = [0,1,2], k = 4
Output: [2,0,1] 

Constraints:
The number of nodes in the list is in the range [0, 500].
-100 <= Node.val <= 100
0 <= k <= 2 * 109


// ctually more challenging than it looks
// My code, optimized

class Solution:
    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        # Handle corner cases
        if head == None or head.next == None: return head
        if k == 0: return head
        
        # first pass, to get length of list
        p, count = head, 0
        while p:
            count += 1
            p = p.next
        
        # check if you can reduce rotations with length of list 
        if k >= count: k = k % count
        # if you have to rotate as many times as size of list, simply return the list    
        if k == 0: return head
        # calculate rotate point (index)
        index, p = count-k-1, head
        # if index == size of list, simply return head
        if index == count: return head
        while index > 0:
            p = p.next
            index -= 1
        # break the list into two list by index point
        # join tail of second list to head of first list to get rotated list
        tail = p
        p = p.next
        start = p
        tail.next = None
        while p.next: p = p.next
        p.next = head
        return start

result -> 
Submission Detail
231 / 231 test cases passed.
Status: Accepted
Runtime: 28 ms (99.5%)
Memory Usage: 13.9 MB (37%)