Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window.

Implement the MovingAverage class:
MovingAverage(int size) Initializes the object with the size of the window size.
double next(int val) Returns the moving average of the last size values of the stream.
 

Example 1:
Input
["MovingAverage", "next", "next", "next", "next"]
[[3], [1], [10], [3], [5]]
Output
[null, 1.0, 5.5, 4.66667, 6.0]

Explanation
MovingAverage movingAverage = new MovingAverage(3);
movingAverage.next(1); // return 1.0 = 1 / 1
movingAverage.next(10); // return 5.5 = (1 + 10) / 2
movingAverage.next(3); // return 4.66667 = (1 + 10 + 3) / 3
movingAverage.next(5); // return 6.0 = (10 + 3 + 5) / 3
 

Constraints:
1 <= size <= 1000
-105 <= val <= 105
At most 104 calls will be made to next.


// My first solution
class MovingAverage:

    def __init__(self, size: int):
        self._limit = size
        self._data = []
        self._start = 0

    def next(self, val: int) -> float:
        self._data.append(val)
        if len(self._data) > self._limit:
            self._start += 1
        return sum(self._data[self._start:])/(len(self._data[self._start:]))

result ->
Submission Detail
11 / 11 test cases passed.
Status: Accepted
Runtime: 125 ms (35%)
Memory Usage: 17.9 MB (<10%)


// My second solution
// Dynamic programming, keep track of sum and use values in array to update sum
class MovingAverage:

    def __init__(self, size: int):
        self._data = []
        self._limit = size
        self._start = 0
        self._size = 0
        self._sum = 0

    def next(self, val: int) -> float:
        if self._size < self._limit: 
            self._size += 1
            self._sum += val
            self._data.append(val)
            return self._sum / self._size
        else:
            self._sum -= self._data[self._start]
            self._start += 1
            self._sum += val
            self._data.append(val)
            return self._sum / self._size

result ->
Submission Detail
11 / 11 test cases passed.
Status: Accepted
Runtime: 52 ms (99.9%)
Memory Usage: 17.8 MB (<10%)


// Inspired, using inbuilt DEQue
// keeps size of array fixed to k, so space O(k)
import collections

class MovingAverage(object):

    def __init__(self, size):
        """
        Initialize your data structure here.
        :type size: int
        """
        self.queue = collections.deque(maxlen=size)
        

    def next(self, val):
        """
        :type val: int
        :rtype: float
        """
        queue = self.queue
        queue.append(val)
        return float(sum(queue))/len(queue)

result ->
Submission Detail
11 / 11 test cases passed.
Status: Accepted
Runtime: 160 ms (18%)
Memory Usage: 17.2 MB (85%)